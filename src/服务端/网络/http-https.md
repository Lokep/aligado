---
title: HTTP 与 HTTPS 的区别
---

# HTTP 与 HTTPS 的区别

- [ ] [HTTPS 是如何保证安全的](https://mp.weixin.qq.com/s/UA-NfJWImOLvoiMTDerBQA)

## HTTP

**特点：无连接、无状态、灵活、简单快速**

- 无连接：

  每一次请求都要连接一次，请求结束就会断掉，不会保持连接

- 无状态：

  每一次请求都是独立的，请求结束不会记录连接的任何信息(提起裤子就不认人的意思)，减少了网络开销，这是优点也是缺点

- 灵活：

  通过 `http` 协议中头部的 `Content-Type` 标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活

- 简单快速：

  发送请求访问某个资源时，只需传送请求方法和 URL 就可以了，使用简单，正由于 http 协议简单，使得 http 服务器的程序规模小，因而通信速度很快

**缺点：无状态、不安全、明文传输、队头阻塞**

- 无状态：

  请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大

- 不安全：

  明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改

- 明文传输：

  报文(header 部分)使用的是明文，直接将信息暴露给了外界， `WIFI` 陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息

- 队头阻塞：

  开启长连接(下面有讲)时，只建立一个 `TCP` 连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)

### HTTP 报文组成部分

**http 报文：由请求报文和响应报文组成**

- 请求报文：由请求行、请求头、空行、请求体四部分组成

  - 请求行：包含 `http` 方法，请求地址， `http` 协议以及版本

  - 请求体：请求的参数

- 响应报文：由状态行、响应头、空行、响应体四部分组成

  - 状态行：包含 http 协议及版本、数字状态码、状态码英文名称

  - 响应体：服务端返回的数据

- 共同点：

  - 请求头/响应头：就是一些 key:value 来告诉服务端我要哪些内容，要注意什么类型等，请求头/响应头每一个字段详解

  - 空行：用来区分首部与实体，因为请求头都是 key:value 的格式。

    当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了

### HTTP 请求方法(9 种)

- HTTP1.0： GET、POST、HEAD

- HTTP1.1： PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT

> 方法介绍：
>
> HEAD：获得报文首部
>
> PATCH：对 PUT 的补充，对已知资源部分更新
>
> DELETE：删除资源
>
> OPTIONS：列出请求资源支持的请求方法，用来跨域请求
>
> TRACE：追踪请求/响应路径，用于测试或诊断
>
> CONNECT：将连接改为管道方式用于代理服务器(隧道代理下面有讲)

### GET 和 POST 的区别

- `GET` 在浏览器回退时是无害的，而 `POST` 会再次发起请求

- `GET` 请求会被浏览器主动缓存，而 `POST` 不会，除非手动设置

- `GET` 请求参数会被安逗保留在浏览器历史记录里，而 `POST` 中的参数不会被保留

- `GET` 请求在 `URL` 中传递的参数有长度限制(浏览器限制大小不同)，而 `POST` 没有限制

- `GET` 参数通过 `URL` 传递， `POST` 放在 `Request body` 中

- `GET` 产生的 `URL` 地址可以被收藏，而 `POST` 不可以

- `GET` 没有 `POST` 安全，因为 `GET` 请求参数直接暴露在 `URL` 上，所以不能用来传递敏感信息

- `GET` 请求只能进行 `URL` 编码，而 POST 支持多种编码方式
- 对参数的数据类型， `GET` 只接受 `ASCII` 字符，而 `POST` 没有限制

- `GET` 产生一个 `TCP` 数据包， `POST` 产生两个数据包(Firefox 只发一次)。

  `GET` 浏览器把 `http header`和 `data` 一起发出去，响应成功 200，

  `POST` 先发送 `header` ，响应 100 continue，再发送 data，响应成功 200

## HTTPS

> `HTTPS` 是超文本传输安全协议，即 `HTTP + SSL/TLS` 。说白了，就是一个加强版的 `HTTP`

![https](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86d024cdc8a54cb9960dca344ff3d512~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

### SSL/TLS

> TLS 是 SSL 的升级版，而且 TLS1.2 版本以下都已废弃，目前主要用的是 TLS 1.2 和 TLS 1.3。而 OpenSSL 则是开源版本的

浏览器和服务器通信之前会先协商，选出它们都支持的`加密套件`, 用来实现安全的通信

例如： RSA-PSK-AES128-GCM-SHA256

![加密套件](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fccc736e57fe45128e6c99f0f9e88ede~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

- RSA：表示握手时用 RSA 算法交换密钥

- PSK：表示使用 PSK 算法签名

- AES128-GCM：表示使用 AES256 对称加密算法通信，密钥长度 128，分组模式 GCM。TLS 1.3 中只剩下称加密算法有 AES 和 CHACHA20，

  分组模式只剩下 GCM 和 POLY1305

- SHA256：表示使用 SHA256 算法验证信息完整性并生成随机数。TLS 1.3 中哈希摘要算法只剩下 SHA256 和 SHA384 了

为了保证安全，TLS 需要保证信息的：机密性、可用性、完整性、认证性、不可否认性

### HTTPS 中 TLS 的加密算法

> 为什么说 https 是安全的？ https 一定是安全的吗？(https 中间人劫持) 有什么解决办法？ https 的证书校验过程是怎么样的？证书校验用到了哪些算法？

**对称加密算法**

就是加密和解密使用同一个密钥。如 AES、DES。加解密过程：

1. 浏览器给服务器发送一个随机数 client-random 和一个支持的加密方法列表
2. 服务器给浏览器返回另一个随机数 server-random 和双方都支持的加密方法
3. 两者用加密方法将两个随机数混合生成密钥，这就是通信双上加解密的密钥

问题是双方如何安全的传递两个随机数和加密方法，直接传给客户端，那过程中就很可能被窃取，别人就能成功解密拿到数据，往下看

**不对称加密算法**

就是一对密钥，有公钥(public key)和私钥(private key)，其中一个密钥加密后的数据，只能让另一个密钥进行解密。如 RSA、ECDHE。加解密过程：

1. 浏览器给服务器发送一个随机数 client-random 和一个支持的加密方法列表
2. 服务器把另一个随机数 server-random、加密方法、公钥传给浏览器
3. 浏览器用公钥将两个随机数加密，生成密钥，这个密钥只能用私钥解密

使用公钥反推出私钥是非常困难，但不是做不到，随着计算机运算能力提高，非对称密钥至少要 2048 位才能保证安全性，这就导致性能上要比对称加密要差很多

#### `TLS`实际用的是两种算法的混合加密

通过 `非对称加密算法` 交换 `对称加密算法` 的密钥，交换完成后，再使用对称加密进行加解密传输数据。

这样就保证了会话的机密性。过程如下:

1. 浏览器给服务器发送一个随机数 client-random 和一个支持的加密方法列表

2. 服务器把另一个随机数 server-random、加密方法、公钥传给浏览器

3. 浏览器又生成另一个随机数 pre-random，并用公钥加密后传给服务器

4. 服务器再用私钥解密，得到 pre-random

5. 浏览器和服务器都将三个随机数用加密方法混合生成最终密钥

这样即便被截持，中间人没有私钥就拿不到 pre-random，就无法生成最终密钥。

可又有问题来了，如果一开始就被 DNS 截持，我们拿到的公钥是中间人的，而不是服务器的，数据还是会被窃取，所以数字证书来了，往下看，先简单说一下摘要算法

**摘要算法**

主要用于保证信息的完整性。常见的`MD5算法`、`散列函数`、`哈希函数`都属于这类算法，其特点就是单向性、无法反推原文

假如信息被截取，并重新生成了摘要，这时候就判断不出来是否被篡改了，所以需要给摘要也通过会话密钥进行加密，

这样就看不到明文信息，保证了安全性，同时也保证了完整性

#### 如何保证数据不被篡改？签名原理和证书?

**数字证书(数字签名)**

它可以帮我们验证服务器身份。因为如果没有验证的话，就可能被中间人劫持，假如请求被中间人截获，中间人把他自己的公钥给了客户端，客户端收到公钥就把信息发给中间人了，中间人解密拿到数据后，再请求实际服务器，拿到服务器公钥，再把信息发给服务器

这样不知不觉间信息就被人窃取了，所以在结合对称和非对称加密的基础上，又添加了数字证书认证的步骤，让服务器证明自己的身份数字证书需要向有权威的认证机构(CA)获取授权给服务器。首先，服务器和 CA 机构分别有一对密钥(公钥和私钥).

**如何生成数字证书**

- CA 机构通过摘要算法生成服务器公钥的摘要(哈希摘要)
- CA 机构通过 CA 私钥及特定的签名算法加密摘要，生成签名

- 把签名、服务器公钥等信息打包放入数字证书，并返回给服务器
- 服务器配置好证书，以后客户端连接服务器，都先把证书发给客户端验证并获取服务器的公钥。

### HTTPS 优缺点

**优点**

- 内容加密，中间无法查看原始内容

- 身份认证，保证用户访问正确。如访问百度，即使 DNS 被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持
- 数据完整性，防止内容被第三方冒充或篡改

- 虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本

**缺点**

- 要钱，功能越强大的证书费用越贵

- 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名

- https 双方加解密，耗费更多服务器资源

- https 握手更耗时，降低一定用户访问速度(优化好就不是缺点了)

### HTTP 与 HTTPS 的区别

- HTTP 标准端口是 80，HTTPS 标准端口是 443

- 连接方式不同，HTTP 三次握手，HTTPS 中 TLS1.2 版本 7 次，TLS1.3 版本 6 次

- HTTP 在 OSI 网络模型中是在应用层，而 HTTPS 的 TLS 是在传输层

- HTTP 是无状态的，HTTPS 是有状态的

- HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的。

- HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。

### HTTPS 的性能优化

**访问速度优化**

1. `会话复用`

上面说了，复用 session 可以减少 CPU 消耗，因为不需要进行非对称密钥交换的计算。

可以提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。

2. `使用 SPDY 或者 HTTP2`

SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，

不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，

但是接收时依然得按照顺序接收，本质上无法解决并发的问题。HTTP2 支持多路复用，有同样的效果。

3. `设置HSTS`

服务端返回一个 HSTS 的 http header，浏览器获取到 HSTS 头部之后，

在一段时间内，不管用户输入www.baidu.com还是http://www.baidu.com ，都会默认将请求内部跳转成https://www.baidu.com。

Chrome, firefox, ie 都支持了 HSTS。

3. `Nginx设置Ocsp stapling`

Ocsp 全称在线证书状态检查协议 (rfc6960)，用来向 CA 站点查询证书状态，比如是否撤销。

通常情况下，浏览器使用 OCSP 协议发起查询请求，CA 返回证书状态内容，然后浏览器接受证书是否可信的状态。

这个过程非常消耗时间，因为 CA 站点有可能在国外，网络不稳定，RTT 也比较大。如果不需要查询则可节约时间。

4. `False start`

简单概括 False start 的原理就是在 clientkeyexchange 发出时将应用层数据一起发出来，能够节省一个 RTT。

**计算性能优化**

1. 优先使用 ECC 椭圆加密算术

2. 使用最新版的 OpenSSL

3. TLS 远程代理计算

4. 硬件加速方案

### SPDY 是什么

SPDY（读作“SPeeDY”）是 Google 开发的基于 TCP 的会话层协议。

主要通过帧、多路复用、请求优先级、HTTP 报头压缩、服务器推送以最小化网络延迟，提升网络速度，优化用户的网络使用体验

原理是在 SSL 层上增加一个 SPDY 会话层，以在一个 TCP 连接中实现并发流。通常的 HTTP GET 和 POST 格式仍然是一样的，

然而 SPDY 为编码和传输数据设计了一个新的帧格式。因为流是双向的，所以可以在客户端和服务端启动

虽然诞生后很快被所有主流浏览器所采用，并且服务器和代理也提供了支持，但是 SPDY 核心人员后来都参加到 HTTP 2.0 开发中去了，

自 HTTP2.0 开发完成就不再支持 SPDY 协议了，并在 Chrome 51 中删掉了 SPDY 的支持
