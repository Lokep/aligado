---
title: HTTP 与 HTTP2的区别
---

# HTTP1.0、HTTP1.1 与 HTTP2 的区别

首先我们先来区别一下 `http 1.0` 与 `http1.1` 的区别

## HTTP 1.0 和 HTTP 1.1 有以下区别

- **连接方面**

  `http1.0` 默认使用非持久连接，而 `http1.1` 默认使用持久连接(长连接 PersistentConnection)。

  `http1.1` 通过使用持久连接来使多个 `http` 请求复用同一个 `TCP` 连接，以此来避免使用非持久连接时每次需要建立连接的时延。

- **资源请求方面**

  在 `http1.0` 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能

  `http1.1` 则在请求头引入了 `range` 头域，它允许只请求资源的某个部分，即返回码是 `206（Partial Content）`

  这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- **缓存方面**

  在 `http1.0` 中主要使用 `header` 里的 `If-Modified-Since` 、 `Expires` 来做为缓存判断的标准，

  `http1.1` 则引入了更多的缓存控制策略，例如 `Etag` 、 `If-Unmodified-Since` 、 `If-Match` 、 `If-None-Match` 等更多可供选择的缓存头来控制缓存策略。

- **`Host`头处理**

  用来指定服务器的域名。

  `http1.0` 中认为每台服务器都绑定一个唯一的 `IP` 地址，因此，请求消息中的 `URL` 并没有传递主机名（hostname）。

  但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 `IP` 地址。

  因此有了 `host` 字段，这样就可以将请求发往到同一台服务器上的不同网站。

- **错误通知的管理**

  在 `HTTP1.1` 中新增了 `24` 个错误状态响应码，

  如`409（Conflict）`表示请求的资源与资源的当前状态发生冲突；

  `410（Gone）`表示服务器上的某个资源被永久性的删除。

- **请求方法新增**

  `http1.1` 相对于 `http1.0` 还**新增了很多请求方法**，如 `PUT` 、 `HEAD` 、 `OPTIONS` 等。

---

## HTTP2.0 和 HTTP1.X 相比的新特性

- **新的二进制格式（Binary Format）**

  `HTTP1.x`的解析是基于文本。

  基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，

  只认 0 和 1 的组合。

  基于这种考虑`HTTP2.0`的协议解析决定采用二进制格式，实现方便且健壮。

  HTTP2 是一个二进制协议，HTTP1 是超文本协议，传输的内容都不是一样的

- **多路复用（MultiPlexing）**

  即连接共享，即每一个`request`都是是用作连接共享机制的。

  一个`request`对应一个 id，这样一个连接上可以有多个`request`，每个连接的`request`可以随机的混杂在一起，

  接收方可以根据`request`的 id 将`request`再归属到各自不同的服务端请求里面。

- **header 压缩**

  如上文中所言，对前面提到过`HTTP1.x`的`header`带有大量信息，而且每次都要重复发送，

  `HTTP2.0`使用`encoder`来减少需要传输的`header`大小，使用 HPACK 算法将头部压缩，用哈夫曼编码建立索表，传送索引大大节约了带宽，

  既避免了重复`header`的传输，又减小了需要传输的大小。

- **服务端推送（server push）**

  同`SPDY`一样，`HTTP2.0`也具有`server push`功能，允许服务端主动推送数据给客户端

- **安全性**

  增加了安全性，使用 HTTP 2.0，要求必须至少 TLS 1.2

## HTTP 3.0/QUIC

由于 HTTP 2.0 依赖于 TCP，TCP 有什么问题那 HTTP2 就会有什么问题。

最主要的还是队头阻塞，在应用层的问题解决了，可是在 TCP 协议层的队头阻塞还没有解决。

TCP 在丢包的时候会进行重传，前面有一个包没收到，就只能把后面的包放到缓冲区，应用层是无法取数据的，

也就是说 HTTP2 的多路复用并行性对于 TCP 的丢失恢复机制不管用，因此丢失或重新排序的数据都会导致交互挂掉

**特点**

- 在传输层直接干掉 TCP，用 UDP 替代

- 实现了一套新的拥塞控制算法，彻底解决 TCP 中队头阻塞的问题

- 实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。

  它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性

- 实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据。

- 集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3

## 附录

### HTTP1 的限制

- `TCP` 连接数限制

  对于同一个域名，浏览器最多只能同时创建 6~8 个 `TCP` 连接

- 线头阻塞 (`Head Of Line Blocking`) 问题

  每个 `TCP` 连接同时只能处理一个请求 - 响应，浏览器按 `FIFO` 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻.

  为了解决此问题，出现了 管线化 - `pipelining` 技术

- `Header` 内容多，而且每次请求 `Header` 不会变化太多，没有相应的压缩传输优化方案

- 为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制

- 明文传输不安全

### HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？

- `HTTP/1.* `一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

- `HTTP/1.1 Pipelining(请求的流水线)`解决方式为：

  若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，

  一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

- `HTTP/2`多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；

### HTTP 流水线(英语：HTTP pipelining)

`HTTP` 流水线是将多个 `HTTP` 请求（`request`）整批提交的技术，而在发送过程中不需先等待服务器的回应。

在使用长链接的情况下，建立一个连接通道后，连接上的消息就类似于

> 请求 1 -> 响应 1 -> 请求 2 -> 响应 2 -> 请求 3 -> 响应 3

pipelining 连接的消息就变成了类似这样

> 请求 1 -> 请求 2 -> 请求 3 -> 响应 1 -> 响应 2 -> 响应 3

管线化是在同一个 `TCP` 连接里发一个请求后不必等其回来就可以继续发请求出去，这可以减少整体的响应时间，

但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题**队头堵塞**

### pipelining 特点

- 管线化机制通过持久连接完成，在 `http1.1` 版本才支持

- 只有 `GET` 请求和 `HEAD` 请求才可以进行管线化，而 `POST` 有所限制

- 初次创建连接时不应启动管线化机制，因为服务器不一定支持 `http1.1` 版本的协议

- 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序就是请求的顺序

- 要求客户端和服务端都支持管线化，但并不要求服务端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可

- 由于上面提到的服务端问题，开户管线化很可能并不会带来大幅度的性能提升，

  而且很多服务端和代理程序对管线化的支持并不好，因为浏览器(Chrome/Firefox)默认并未开启管线化支持

### 什么是持久连接/长连接

- `http1.0` 协议采用的是"请求-应答"模式，当使用普通模式，每个请求/应答客户与服务器都要新建一个连接，

  完成之后立即断开连接( `http` 协议为无连接的协议)

- `http1.1` 版本支持长连接，即请求头添加 `Connection: Keep-Alive`，

  使用`Keep-Alive`模式(又称持久连接，连接复用)建立一个 `TCP` 连接后使客户端到服务端的连接持续有效，

  可以发送/接受多个 `http` 请求/响应，当出现对服务器的后续请求时，`Keep-Alive` 功能避免了建立或者重新建立连接

### http 中的 keep-alive 有什么作用

响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求

### 长连接优缺点(HTTP1 的优缺点)

**优点**

- 减少 CPU 及内存的使用，因为不需要经常建立和关闭连接

- 支持管道化的请求及响应模式

- 减少网络堵塞，因为减少了 `TCP` 请求

- 减少了后续请求的响应时间，因为不需要等待建立 `TCP` 、握手、挥手、关闭 `TCP` 的过程
- 发生错误时，也可在不关闭连接的情况下进行错误提示

**缺点**

- 一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，

  而且长连接时间的长短，直接影响到服务器的并发数

- 可能造成队头堵塞，造成信息延迟

### 如何避免长连接资源浪费？

- 客户端请求头声明：Connection: close，本次通信后就关闭连接

- 服务端配置：如 Nginx，设置 keepalive_timeout 设置长连接超时时间，keepalive_requests 设置长连接请求次数上限

- 系统内核参数设置：

  - net.ipv4.tcp_keepalive_time = 60，连接闲置 60 秒后，服务端尝试向客户端发送侦测包，判断 TCP 连接状态，如果没有收到 ack 反馈就在

  - net.ipv4.tcp_keepalive_intvl = 10，就在 10 秒后再次尝试发送侦测包，直到收到 ack 反馈，一共会

  - net.ipv4.tcp_keepalive_probes = 5，一共会尝试 5 次，要是都没有收到就关闭这个 TCP 连接了

### 如何解决 HTTP 的队头阻塞问题

> http1.0 协议采用的是请求-应答模式，报文必须是一发一收，
>
> 就形成了一个先进先出的串行队列，没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求最先处理，
>
> 就导致如果队首的请求耗时过长，后面的请求就只能处于阻塞状态，这就是著名的队头阻塞问题。解决如下：

- 并发连接

  因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。

  现在的浏览器标准中一个域名并发连接可以有 6\~8 个，记住是 6\~8 个

- 域名分片

  一个域名最多可以并发 6~8 个，那咱就多来几个域名

而在 HTTP2.0 下，可以一瞬间加载出来很多资源，因为支持多路复用，可以在一个 TCP 连接中发送多个请求

### 服务器推送到底是什么？

服务端推送能把客户端所需要的资源伴随着`index.html`一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：

### 为什么需要头部压缩？

假定一个页面有 100 个资源需要加载（这个数量对于今天的 `Web` 而言还是挺保守的）, 而每一次请求都有 1kb 的消息头（这同样也并不少见，因为 `Cookie` 和引用等东西的存在）, 则至少需要多消耗 100kb 来获取这些消息头。

`HTTP2.0`可以维护一个字典，差量更新`HTTP`头部，大大降低因头部传输产生的流量。具体参考：`HTTP/2` 头部压缩技术介绍

### HTTP2.0 多路复用有多好？

`HTTP` 性能优化的关键并不在于高带宽，而是低延迟。

`TCP` 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。

这种调谐则被称为 `TCP` 慢启动。

由于这种原因，让原本就具有突发性和短时性的 `HTTP` 连接变的十分低效。

`HTTP/2` 通过让所有数据流共用同一个连接，可以更有效地使用 `TCP` 连接，让高带宽也能真正的服务于 `HTTP` 的性能提升。

### HTTP 代理

> 常见的代理有两种：`普通代理(中间人代理)`，`隧道代理`

- **普通代理(中间人代理)**

![普通代理(中间人代理)](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c531bafbf55f4c7e8f3fe06b7a107dc7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

代理服务器相当于一个中间人，一直帮两边传递东西

不过它可以在中间可以帮我们过滤、缓存、负载均衡(多台服务器共用一台代理情况下)等一些处理

注意，实际场景中客户端和服务器之间可能有多个代理服务器

- **隧道代理**

  客户端通过 `CONNECT` 方法请求隧道代理创建一个可以到任意目标服务器和端口号的 `TCP` 连接，

  创建成功之后隧道代理只做请求和响应数据的转发，中间它不会做任何处理

  ![隧道代理](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2760210f0b8f4ee9be895fa76d9b4661~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

  我们都知道 `https` 服务是需要网站有证书的，而代理服务器显然没有，所以浏览器和代理之间无法创建 `TLS` ，

  所以就有了隧道代理，它把浏览器的数据原样透传，这样就实现了通过中间代理和服务端进行 `TLS` 握手，然后进行加密传输
