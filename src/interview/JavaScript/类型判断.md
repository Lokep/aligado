---
title: 类型判断
toc: menu
order: 2
---

# 类型判断

## Javascript 数据类型

JavaScript 有八种内置类型，除对象外，其他统称为“基本类型”。

- 空值（null)
- 未定义(undefined)
- 布尔值（boolean)
- 数字（number)
- 字符串（string)
- 对象 (object)
- 符号（symbol, ES6 中新增)
- Symbol： 是 ES6 中引入的一种原始数据类型，表示独一无二的值。
- BigInt：是 ES2020 引入的一种新的数据类型，用来解决 JavaScript 中数字只能到 53 个二进制位（JavaScript 所有数字都保存成 64 位浮点数，大于这个范围的整数，无法精确表示的问题。

## 判断数据类型

1. typeof

```javascript
typeof null; // object
typeof undefined; // undefined
typeof false; // boolean
typeof 1; // number
typeof '1'; // string
typeof {}; // object
typeof []; // object
typeof (() => {}); // function
typeof Symbol(1); // symbol
typeof BigInt(1000000); // bigint
```

如上结果可见，当我们使用 `typeof` 来判断 `Object` 、 `Array` 、 `Map` 、 `Set` 等类型时，都会返回 `object`

为此，引入了 `instanceof` 。

<br />
<br />
<br />
<br />
<br />
<br />

2. instanceof

`instanceof` 与 `typeof` `相比，instanceof` 方法要求开发者明确的确认对象为某特定类型。  
即 `instanceof` 用于判断引用类型属于哪个构造函数的方法。

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

`instanceof` 操作符检测过程中也会将继承关系考虑在内，所以 `instanceof` 可以在继承关系中用来判断一个实例是否属于它的父类型。

```javascript
const fn = () => {};
const list = [];

fn instanceof Function; // true
fn instanceof Object; // true

list instanceof Function; // true
list instanceof Object; // true
```

`instanceof` 的判断逻辑是

顺着 fn 的 `__proto__` 一层一层往上，是否对应到 Function.prototype 再往上，看是否对应着 Object.prototype

<br /><br /><br /><br /><br /><br />

3. constructor

`constructor` 判断方法跟 `instanceof` 相似, 但是 `constructor` 检测 `Object` 与 `instanceof` 不一样, `constructor` 还可以处理基本数据类型的检测, 不仅仅是对象类型。

**注意**

a. `null` 和 `undefined` 没有 `constructor` ; b. 判断数字时使用(), 比如 (123).constructor, 如果写成 123.constructor 会报错; c. `constructor` 在类继承时会出错, 因为 `Object` 被覆盖掉了, 检测结果就不对了

```javascript
const n = 1;
const s = `1`;
const a = [];
const o = {};
const f = () => {};

class cls {}

class chd extends cls {}

n.constructor === Number;
s.constructor === String;
f.constructor === Function;
o.constructor === Object;
a.constructor === Array;

cls.constructor === Function;
```

<br />
<br />
<br />
<br />
<br />
<br />

4. Object.prototype.toString.call

`Object.prototype.toString` 方法返回一个表示该对象的字符串。

```javascript
function Dog(name) {
  this.name = name;
}

Dog.prototype.toString = function dogToString() {
  return `${this.name}`;
};

const dog = new Dog('Gabby');
const obj = {};

console.log(dog.toString()); // 'Gabby'
console.log(obj.toString()); // '[object Object]'
```

所以我们可以应用到类型判断上，且该方法十分严谨

```javascript
const generator = (type) => (target) =>
  Object.prototype.toString.call(target) === '[object ' + type + ']';

const isFunction = generator('Function');
const isArray = generator('Array');
const isDate = generator('Date');
const isRegExp = generator('RegExp');

isFunction(() => {}); // true
isArray([]); // true
```

<br />
<br />
<br />
<br />
<br />
<br />
